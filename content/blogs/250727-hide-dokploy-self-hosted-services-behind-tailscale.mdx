export const metadata = {
    title: "Hide Dokploy self-hosted services behind TailScale",
    publishDate: "2025-07-27",
    description: ".",
    category: "Tutorial",
    cover_image: "https://images.pexels.com/photos/1181671/pexels-photo-1181671.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1",
};

- [ ] context

# What & Why
- [ ] new section name
- [ ] Skip this section button

## Dokploy

[Dokploy](https://dokploy.com/) is an open-source, self-hostable deployment platform that simplifies the process of managing and deploying applications. 

It acts as an alternative to services like [Heroku](https://www.heroku.com/), [Vercel](https://vercel.com/), and [Netlify](https://www.netlify.com/), providing developers with full control over their deployment pipelines and hosting environments. 

Dokploy leverages [Docker](https://www.docker.com/) and [Traefik](https://traefik.io/) for robust container management, offering features such as flexible application deployment using various builders ([Nixpacks](https://nixpacks.com/), [Heroku Buildpacks](https://devcenter.heroku.com/articles/buildpacks), custom Dockerfiles), native [Docker Compose](https://docs.docker.com/compose/) support, database management with backups (for [MySQL](https://www.mysql.com/), [PostgreSQL](https://www.postgresql.org/), [MongoDB](https://www.mongodb.com/), [MariaDB](https://mariadb.org/), [Redis](https://redis.io/)), real-time monitoring, and API/CLI access. 

It's designed to provide simplicity, flexibility, and scalability for a wide range of applications and databases, allowing users to deploy to single or multiple remote servers.

## Traefik
[Traefik](https://traefik.io/) is an open-source [Edge Router](https://www.cisco.com/site/us/en/learn/topics/networking/what-is-an-edge-router.html) that makes publishing your services an easy experience. It receives requests and finds out which components are responsible for handling them. 

In Dokploy, Traefik acts as the modern [HTTP reverse proxy](https://www.cloudflare.com/learning/cdn/glossary/reverse-proxy/) and [load balancer](https://www.cloudflare.com/learning/performance/what-is-load-balancing/) that facilitates seamless routing of requests to the various deployed applications. It plays a crucial role in Dokploy's architecture by automatically discovering services and configuring routes, thanks to its integration with Docker. 

This eliminates the need for manual configuration updates when applications are scaled up or down, or when new services are introduced. Traefik's dynamic capabilities allow it to efficiently manage incoming traffic, ensuring requests are directed to the correct application containers and enabling features like [SSL/TLS](https://www.cloudflare.com/learning/ssl/how-does-ssl-work/) termination, request routing based on hostnames or paths, and load balancing across multiple instances of an application. 

In essence, Traefik acts as the intelligent traffic controller within Dokploy, making deployments more robust, scalable, and easier to manage.

## TailScale
[Tailscale](https://tailscale.com) is a zero-config [VPN](https://www.cloudflare.com/learning/access-management/what-is-a-vpn/) that creates a secure network between your devices, no matter where they are. It simplifies secure access by building on the [WireGuard protocol](https://nordvpn.com/blog/vpn-wireguard/). 

In Dokploy, Tailscale could potentially be used to create a secure and [private network](https://nordvpn.com/blog/what-is-private-network/) for connecting Dokploy instances or deployed applications across different servers or cloud providers, without the complexities of traditional VPN setups. 

This would allow for secure communication between various components of a Dokploy-managed infrastructure, even if they are geographically dispersed, by essentially creating a [Mesh VPN](https://tailscale.com/learn/understanding-mesh-vpns) where all authorized devices can communicate directly and securely.

While not a core component of Dokploy's immediate deployment mechanism like Traefik, Tailscale could enhance the security and networking capabilities for more distributed or complex Dokploy deployments.

## Why
- [ ] Why

# How
- [ ] How
  Key Idea: Tailscale as a Certificate Resolver for Traefik

  Traefik v3.0 and later versions have native support for Tailscale as a TLS certificate resolver. This is the most straightforward approach for your setup. Here's how it works:

  Tailscale HTTPS Certificates: Tailscale can automatically provide valid HTTPS certificates for services within your tailnet (e.g., your-service.your-machine.ts.net). These certificates are issued by Let's Encrypt, and Tailscale handles the renewal process.

  Traefik Integration: Traefik can be configured to use this Tailscale feature to obtain certificates for your services. When Traefik receives an HTTPS request for a *.ts.net domain, it queries the local Tailscale daemon for the certificate.

# Prerequisites
- A deployed Dokploy server
- Set up your Tailscale Network

- [ ] Specify current versions of Dokploy, (Traefik), and Tailscale
- A domain name
  - [ ] Verify Traefik interaction with `*.ts.net` domains
  - [ ] Dokploy & Traefik is recommended to use a domain name
  - [ ] TailScale don't support creating `*.ts.net` domains
  - [ ] Recommend to use Domain providers that support DNS-01 challenge (list some of with referal links)

# Steps
## TailScale
- [ ] (Optional) enable MagicDNS

## Main
- [ ] DNS
- [ ] Dokploy
- [ ] Individual services

## Public services

# (Optional) SSL
- [ ] DNS-01 challenge
  - [ ] What & Why
  - [ ] How
    The DNS-01 challenge works like this:
    1. Request: When Traefik needs a certificate for service_name.my.domain, it sends a request to the ACME server (e.g., Let's Encrypt).
    2. Challenge: The ACME server responds with a unique string (a "token") and asks Traefik to create a specific TXT record at a particular subdomain (usually _acme-challenge.service_name.my.domain) in your public DNS.
    3. Validation: Traefik, using the credentials you provide, instructs your DNS provider's API to add this TXT record.
    4. Verification: The ACME server then queries the global DNS system for that specific TXT record. If it finds the correct token, it validates that you control the domain.
    5. Issuance: Once validated, the ACME server issues the SSL certificate to Traefik.
    6. Renewal: Traefik automatically handles renewal before the certificate expires.
  - [ ] Use staging environment to test the challenge

  Key Traefik Configuration Elements for DNS-01 Challenge

  You'll typically configure this in your Traefik static configuration file (e.g., traefik.yml or traefik.toml) and through environment variables for sensitive API keys.

  1. Define an Entrypoint for HTTPS (Websecure)


  First, ensure Traefik listens on the standard HTTPS port.


    # traefik.yml
    entryPoints:
      websecure:
        address: ":443"
        # Optional: Redirect HTTP to HTTPS, useful if you expose port 80 externally
        # but in your case, since it's behind Tailscale, it might not be strictly necessary
        # and could be handled by a router later if needed.
        # http:
        #   redirections:
        #     entryPoint:
        #       to: websecure
        #       scheme: https

  2. Define a Certificate Resolver (ACME)


  This is the core of the SSL configuration.


    # traefik.yml
    certificatesResolvers:
      letsencrypt: # You can name this anything, "letsencrypt" is common
        acme:
          email: your-email@example.com # Important: For renewal notifications from Let's Encrypt
          storage: "/path/to/acme.json" # Path where Traefik stores certificates and ACME state
          # For Docker, this path should be a volume mount (e.g., /certs/acme.json)
          caServer: "https://acme-v02.api.letsencrypt.org/directory" # Production ACME server
          # caServer: "https://acme-staging-v02.api.letsencrypt.org/directory" # **Use this for testing!** Avoid hitting rate limits.
    
          dnsChallenge:
            provider: cloudflare # Or whatever your DNS provider is (e.g., google, route53, digitalocean, etc.)
            delayBeforeCheck: 0 # Optional: Time in seconds to wait before checking DNS propagation. Adjust if you have issues.
            resolvers:
              - "1.1.1.1:53" # Optional: Specify custom DNS resolvers for validation. Good for debugging.
              - "8.8.8.8:53"

  Key Points for certificatesResolvers:


  - email: Crucial for Let's Encrypt to contact you regarding certificate expiry or issues.
  - storage: This file (acme.json) stores your certificates and ACME account information. It must be persistent (e.g., a Docker volume mount) so Traefik doesn't have to re-obtain certificates every time it restarts.
  - caServer:
    - https://acme-staging-v02.api.letsencrypt.org/directory: ALWAYS start with the staging server for testing! This allows you to debug your setup without hitting Let's Encrypt's strict rate limits. Once everything works, switch to the production server.
    - https://acme-v02.api.letsencrypt.org/directory: The production server for live certificates.
  - dnsChallenge.provider: This is where you specify your DNS provider. Traefik supports a wide range of providers (e.g., Cloudflare, AWS Route 53, Google Cloud DNS, DigitalOcean, OVH, etc.). The specific provider name (e.g., cloudflare) must match Traefik's supported list.
  - delayBeforeCheck: Sometimes, DNS propagation can take a moment. If you experience validation failures, increasing this delay (e.g., to 5 or 10 seconds) can help.

  3. Provide DNS Provider Credentials (Environment Variables)


  This is perhaps the most crucial part. Traefik needs credentials to interact with your DNS provider's API. These should always be passed as environment variables, not directly in your configuration file, for security.

  The specific environment variables depend on your DNS provider.

  Example for Cloudflare:


    # In your docker-compose.yml for the Traefik service:
    environment:
      - CF_API_EMAIL=your-cloudflare-email@example.com
      - CF_API_KEY=your_cloudflare_global_api_key_or_scoped_token
      # OR if using a specific API token for security (recommended):
      # - CF_DNS_API_TOKEN=your_cloudflare_scoped_api_token


  - Cloudflare Specifics:
    - CF_API_EMAIL and CF_API_KEY (Global API Key): Easier but less secure. The API key has full access to your account.
    - CF_DNS_API_TOKEN (Scoped API Token): Highly Recommended. Create an API token in Cloudflare with permissions only to "Zone -> DNS -> Edit" for the specific zone(s) you need. This significantly limits the blast radius if the key is compromised.
  Example for AWS Route 53:


    # In your docker-compose.yml for the Traefik service:
    environment:
      - AWS_ACCESS_KEY_ID=YOUR_AWS_ACCESS_KEY_ID
      - AWS_SECRET_ACCESS_KEY=YOUR_AWS_SECRET_ACCESS_KEY
      # Optional: For specific regions
      # - AWS_REGION=us-east-1


  - AWS Specifics: Create an IAM user with programmatic access and a policy that grants route53:ChangeResourceRecordSets permission for your hosted zone.
  Consult Traefik's Documentation: You must refer to the Traefik documentation for ACME DNS Challenge Providers to find the correct environment variables for your specific DNS provider.
- [ ] SSL for Dokploy
- [ ] SSL for individual services